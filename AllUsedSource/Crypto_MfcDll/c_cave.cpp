// c_cave.cpp: implementation of the cave class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "c_cave.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

c_cave::c_cave()
{

}

c_cave::~c_cave()
{

}
unsigned char CaveTable[256] = 
{ 
   	0xD9, 0x23, 0x5F, 0xE6, 0xCA, 0x68, 0x97, 0xB0, 0x7B, 0xF2, 0x0C, 0x34, 0x11, 0xA5, 0x8D, 0x4E, 
	0x0A, 0x46, 0x77, 0x8D, 0x10, 0x9F, 0x5E, 0x62, 0xF1, 0x34, 0xEC, 0xA5, 0xC9, 0xB3, 0xD8, 0x2B, 
	0x59, 0x47, 0xE3, 0xD2, 0xFF, 0xAE, 0x64, 0xCA, 0x15, 0x8B, 0x7D, 0x38, 0x21, 0xBC, 0x96, 0x00, 
	0x49, 0x56, 0x23, 0x15, 0x97, 0xE4, 0xCB, 0x6F, 0xF2, 0x70, 0x3C, 0x88, 0xBA, 0xD1, 0x0D, 0xAE, 
	0xE2, 0x38, 0xBA, 0x44, 0x9F, 0x83, 0x5D, 0x1C, 0xDE, 0xAB, 0xC7, 0x65, 0xF1, 0x76, 0x09, 0x20, 
	0x86, 0xBD, 0x0A, 0xF1, 0x3C, 0xA7, 0x29, 0x93, 0xCB, 0x45, 0x5F, 0xE8, 0x10, 0x74, 0x62, 0xDE, 
	0xB8, 0x77, 0x80, 0xD1, 0x12, 0x26, 0xAC, 0x6D, 0xE9, 0xCF, 0xF3, 0x54, 0x3A, 0x0B, 0x95, 0x4E, 
	0xB1, 0x30, 0xA4, 0x96, 0xF8, 0x57, 0x49, 0x8E, 0x05, 0x1F, 0x62, 0x7C, 0xC3, 0x2B, 0xDA, 0xED, 
	0xBB, 0x86, 0x0D, 0x7A, 0x97, 0x13, 0x6C, 0x4E, 0x51, 0x30, 0xE5, 0xF2, 0x2F, 0xD8, 0xC4, 0xA9, 
	0x91, 0x76, 0xF0, 0x17, 0x43, 0x38, 0x29, 0x84, 0xA2, 0xDB, 0xEF, 0x65, 0x5E, 0xCA, 0x0D, 0xBC, 
	0xE7, 0xFA, 0xD8, 0x81, 0x6F, 0x00, 0x14, 0x42, 0x25, 0x7C, 0x5D, 0xC9, 0x9E, 0xB6, 0x33, 0xAB, 
	0x5A, 0x6F, 0x9B, 0xD9, 0xFE, 0x71, 0x44, 0xC5, 0x37, 0xA2, 0x88, 0x2D, 0x00, 0xB6, 0x13, 0xEC, 
	0x4E, 0x96, 0xA8, 0x5A, 0xB5, 0xD7, 0xC3, 0x8D, 0x3F, 0xF2, 0xEC, 0x04, 0x60, 0x71, 0x1B, 0x29, 
	0x04, 0x79, 0xE3, 0xC7, 0x1B, 0x66, 0x81, 0x4A, 0x25, 0x9D, 0xDC, 0x5F, 0x3E, 0xB0, 0xF8, 0xA2, 
	0x91, 0x34, 0xF6, 0x5C, 0x67, 0x89, 0x73, 0x05, 0x22, 0xAA, 0xCB, 0xEE, 0xBF, 0x18, 0xD0, 0x4D, 
	0xF5, 0x36, 0xAE, 0x01, 0x2F, 0x94, 0xC3, 0x49, 0x8B, 0xBD, 0x58, 0x12, 0xE0, 0x77, 0x6C, 0xDA
};
// { 0xd9, 0x23, 0x5f, 0xe6, 0xca, 0x68, 0x97, 0xb0, 
// 0x7b, 0xf2, 0x0c, 0x34, 0x11, 0xa5, 0x8d, 0x4e, 
// 0x0a, 0x46, 0x77, 0x8d, 0x10, 0x9f, 0x5e, 0x62, 
// 0xf1, 0x34, 0xec, 0xa5, 0xc9, 0xb3, 0xd8, 0x2b, 
// 0x59, 0x47, 0xe3, 0xd2, 0xff, 0xae, 0x64, 0xca, 
// 0x15, 0x8b, 0x7d, 0x38, 0x21, 0xbc, 0x96, 0x00, 
// 0x49, 0x56, 0x23, 0x15, 0x97, 0xe4, 0xcb, 0x6f, 
// 0xf2, 0x70, 0x3c, 0x88, 0xba, 0xd1, 0x0d, 0xae, 
// 0xe2, 0x38, 0xba, 0x44, 0x9f, 0x83, 0x5d, 0x1c, 
// 0xde, 0xab, 0xc7, 0x65, 0xf1, 0x76, 0x09, 0x20, 
// 0x86, 0xbd, 0x0a, 0xf1, 0x3c, 0xa7, 0x29, 0x93, 
// 0xcb, 0x45, 0x5f, 0xe8, 0x10, 0x74, 0x62, 0xde, 
// 0xb8, 0x77, 0x80, 0xd1, 0x12, 0x26, 0xac, 0x6d, 
// 0xe9, 0xcf, 0xf3, 0x54, 0x3a, 0x0b, 0x95, 0x4e, 
// 0xb1, 0x30, 0xa4, 0x96, 0xf8, 0x57, 0x49, 0x8e, 
// 0x05, 0x1f, 0x62, 0x7c, 0xc3, 0x2b, 0xda, 0xed, 
// 0xbb, 0x86, 0x0d, 0x7a, 0x97, 0x13, 0x6c, 0x4e, 
// 0x51, 0x30, 0xe5, 0xf2, 0x2f, 0xd8, 0xc4, 0xa9, 
// 0x91, 0x76, 0xf0, 0x17, 0x43, 0x38, 0x29, 0x84, 
// 0xa2, 0xdb, 0xef, 0x65, 0x5e, 0xca, 0x0d, 0xbc, 
// 0xe7, 0xfa, 0xd8, 0x81, 0x6f, 0x00, 0x14, 0x42, 
// 0x25, 0x7c, 0x5d, 0xc9, 0x9e, 0xb6, 0x33, 0xab, 
// 0x5a, 0x6f, 0x9b, 0xd9, 0xfe, 0x71, 0x44, 0xc5, 
// 0x37, 0xa2, 0x88, 0x2d, 0x00, 0xb6, 0x13, 0xec, 
// 0x4e, 0x96, 0xa8, 0x5a, 0xb5, 0xd7, 0xc3, 0x8d, 
// 0x3f, 0xf2, 0xec, 0x04, 0x60, 0x71, 0x1b, 0x29, 
// 0x04, 0x79, 0xe3, 0xc7, 0x1b, 0x66, 0x81, 0x4a, 
// 0x25, 0x9d, 0xdc, 0x5f, 0x3e, 0xb0, 0xf8, 0xa2, 
// 0x91, 0x34, 0xf6, 0x5c, 0x67, 0x89, 0x73, 0x05, 
// 0x22, 0xaa, 0xcb, 0xee, 0xbf, 0x18, 0xd0, 0x4d, 
// 0xf5, 0x36, 0xae, 0x01, 0x2f, 0x94, 0xc3, 0x49, 
// 0x8b, 0xbd, 0x58, 0x12, 0xe0, 0x77, 0x6c, 0xda }; 

unsigned char ibox[256] =
{ 0xdd, 0xf3, 0xf7, 0x90, 0x0b, 0xf5, 0x1a, 0x48, 
0x20, 0x3c, 0x84, 0x04, 0x19, 0x16, 0x22, 0x47, 
0x6d, 0xa8, 0x8e, 0xc8, 0x9f, 0x8d, 0x0d, 0xb5, 
0xc2, 0x0c, 0x06, 0x2f, 0x43, 0x60, 0xf0, 0xa4, 
0x08, 0x99, 0x0e, 0x36, 0x98, 0x3d, 0x2e, 0x81, 
0xcb, 0xab, 0x5c, 0xd5, 0x3f, 0xee, 0x26, 0x1b, 
0x94, 0xd9, 0xfc, 0x68, 0xde, 0xcd, 0x23, 0xed, 
0x96, 0xc5, 0xdc, 0x45, 0x09, 0x25, 0x4f, 0x2c, 
0x62, 0x53, 0xbf, 0x1c, 0x95, 0x3b, 0x89, 0x0f, 
0x07, 0x56, 0x7f, 0xbd, 0xaa, 0xb7, 0xff, 0x3e, 
0x86, 0x77, 0x54, 0x41, 0x52, 0xd4, 0x49, 0xb8, 
0xc7, 0x9e, 0x82, 0x71, 0x2a, 0xd0, 0x78, 0x9c, 
0x1d, 0x6a, 0x40, 0xae, 0xf4, 0xaf, 0xf2, 0xe9, 
0x33, 0x80, 0x61, 0xb4, 0xc0, 0x10, 0xa7, 0xbb, 
0xb6, 0x5b, 0x73, 0x72, 0x79, 0x7c, 0x8c, 0x51, 
0x5e, 0x74, 0xfb, 0xe6, 0x75, 0xd6, 0xef, 0x4a, 
0x69, 0x27, 0x5a, 0xb3, 0x0a, 0xe8, 0x50, 0xa0, 
0xca, 0x46, 0xc3, 0xea, 0x76, 0x15, 0x12, 0xc6, 
0x03, 0x97, 0xa3, 0xd1, 0x30, 0x44, 0x38, 0x91, 
0x24, 0x21, 0xc1, 0xdb, 0x5f, 0xe3, 0x59, 0x14, 
0x87, 0xa2, 0xa1, 0x92, 0x1f, 0xe2, 0xbc, 0x6e, 
0x11, 0xbe, 0x4c, 0x29, 0xe4, 0xc9, 0x63, 0x65, 
0xcc, 0xfa, 0xf1, 0x83, 0x6b, 0x17, 0x70, 0x4d, 
0x57, 0xd3, 0xfe, 0x6f, 0xa6, 0x4b, 0xa9, 0x42, 
0x6c, 0x9a, 0x18, 0x8a, 0xd2, 0x39, 0x8f, 0x58, 
0x13, 0xad, 0x88, 0x28, 0xb0, 0x35, 0xd7, 0xe1, 
0x5d, 0x93, 0xc4, 0xb9, 0x55, 0x2b, 0x7d, 0xce, 
0xe0, 0x31, 0xfd, 0x9b, 0x3a, 0x00, 0x34, 0xe5, 
0xd8, 0xcf, 0xa5, 0x9d, 0xac, 0xdf, 0x7b, 0xf9, 
0x85, 0x67, 0x8b, 0xf6, 0xf8, 0x37, 0x2d, 0x7e, 
0x1e, 0xb2, 0x66, 0x01, 0x64, 0x05, 0xeb, 0x02, 
0xec, 0xe7, 0xb1, 0x7a, 0x32, 0xda, 0xba, 0x4e }; 

unsigned char c_cave::bit_val(const unsigned char octet, const int bit)
{
	return((octet << (7 - bit)) & 0x80); 
}

//右移LFSR一位，并将计算好的A7填充到A7的位置上，D0抛弃
//[A7,A6...A0][B7,B6...B0][C7,C6...C0][D7,D6...D0]
void c_cave::LFSR_cycle(void) 
{ 
	unsigned char temp; 
	int i; 

	temp = bit_val(LFSR_B,6); 
	temp ^= bit_val(LFSR_D,2); 
	temp ^= bit_val(LFSR_D,1); 
	temp ^= bit_val(LFSR_D,0); 

	/* Shift right LFSR, Discard LFSR_D[0] bit */ 

	for (i = 3; i > 0; i--) 
	{ 
		LFSR[i] >>= 1; 
		if (LFSR[i-1] & 0x01) 
		LFSR[i] |= 0x80; 
	} 
	LFSR[0] >>= 1; 
	LFSR_A |= temp; 
} 

//Register[] 循环右移一位
//[R0,R1,...R15]
void c_cave::Rotate_right_registers(void) 
{ 
	unsigned int temp_reg; 
	int i; 

	temp_reg = Register[15]; /* save lsb */ 

	for (i = 15; i > 0; i--) 
	{ 
		Register[i] >>= 1; 
		if (Register[i-1] & 0x01) 
			Register[i] |= 0x80; 
	} 

	Register[0] >>= 1; 
	if (temp_reg & 0x01) 
		Register[0] |= 0x80; 
} 

//cave算法，根据标准的伪代码而来
void c_cave::CAVE(const int number_of_rounds,int *offset_1, int *offset_2) 
{ 
	unsigned char temp_reg0; 
	unsigned char lowNibble; 
	unsigned char hiNibble; 
	unsigned char temp; 
	int round_index; 
	int R_index; 
	int fail_count; 
	unsigned char T[16]; 

	for (round_index = number_of_rounds - 1; round_index >= 0; round_index--) 
	{ 
		/* save R0 for reuse later */ 
		temp_reg0 = Register[0]; 

		for (R_index = 0; R_index < 16; R_index++) 
		{ 
			fail_count = 0; 
			while(1) 
			{  
				*offset_1 += (LFSR_A ^ Register[R_index]); 
				/* will overflow; mask to prevent */ 
				*offset_1 &= 0xff; 
				lowNibble = CaveTable[*offset_1] & LOMASK; 
				if (lowNibble == (Register[R_index] & LOMASK)) 
				{ 
					LFSR_cycle(); 
					fail_count++; 
					if (fail_count == 32) 
					{ 
						LFSR_D++; /* no carry to LFSR_C */ 
						break; 
					} 
				} 
				else break; 
			} 
		    fail_count = 0;
			while(1) 
			{ 
				*offset_2 += (LFSR_B ^ Register[R_index]); 
				/* will overflow; mask to prevent */ 
				*offset_2 &= 0xff; 
				hiNibble = CaveTable[*offset_2] & HIMASK; 
				if (hiNibble == (Register[R_index] & HIMASK)) 
				{ 
					LFSR_cycle(); 
					fail_count++;
					if (fail_count == 32) 
					{ 
						LFSR_D++; /* no carry to LFSR_C */ 
						break; 
					} 
				} 
				else 
				break; 
			} 

			temp = lowNibble | hiNibble; 
			if (R_index == 15) 
				Register[R_index] = temp_reg0 ^ temp; 
			else 
				Register[R_index] = Register[R_index+1] ^ temp; 

			LFSR_cycle(); 
		} 

		Rotate_right_registers(); 

		/* shuffle the mixing registers */ 
		for (R_index = 0; R_index < 16; R_index++) 
		{ 
			temp = CaveTable[16*round_index + R_index] & LOMASK; 
			T[temp] = Register[R_index]; 
		} 
		for (R_index = 0; R_index < 16; R_index++) 
			Register[R_index] = T[R_index]; 
	} 
} 

void c_cave::mul10(unsigned char i64[8], unsigned int carry) 
{ 
	int i; 
	unsigned int temp; 

	for (i = 7; i >= 0; i--) 
	{ 
		temp = ((unsigned int)(i64[i]) * 10) + carry; 
		i64[i] = temp & 0xFF; 
		carry = temp >> 8; 
	} 
} 

unsigned long c_cave::Calc_Checksum(const unsigned char A_key[8]) 
{ 
	int i,offset_1,offset_2; 
	unsigned long A_key_checksum; 

	/* see if 32 MSB are zero */ 

	if ((A_key[0] | A_key[1] | A_key[2] | A_key[3]) != 0) 
	{ 
		/* put 32 MSB into LFSR */ 
		for (i = 0; i < 4; i++) 
		LFSR[i] = A_key[i]; 
	} 
	else 
	{ 
		/* put ESN into LFSR */ 
		for (i = 0; i < 4; i++) 
		LFSR[i] = ESN[i]; 
	} 

	/* put A_key into r0-r7 */ 

	for (i = 0; i < 8; i++) 
		Register[i] = A_key[i]; 
	Register[8] = AAV; 

	/* put ls 24 bits of A_key into r9-r11 */ 

	for (i = 9; i < 12; i++) 
		Register[i] = A_key[5+i-9]; 

	/* put ESN into r12-r15 */ 
	for (i = 12; i < 16; i++) 
		Register[i] = ESN[i-12]; 

	offset_1 = offset_2 = 128; 
	CAVE(8, &offset_1, &offset_2); 
	A_key_checksum =
		( ((unsigned long)(Register[0] ^ Register[13]) << 16) + 
		((unsigned long)(Register[1] ^ Register[14]) << 8) + 
		((unsigned long)(Register[2] ^ Register[15]) )) & 0x3ffff; 

	return (A_key_checksum); 
} 

void c_cave::A_Key_Checksum(const char A_KEY_DIGITS[20], char A_KEY_CHECKSUM[6]) 
{ 
	int i; 
	unsigned char temp_A_key[8]; 
	unsigned long A_key_checksum; 

	/* convert digits to 64-bit representation in temp_A_key */ 

	for (i = 0; i < 8; i++) 
	temp_A_key[i] = 0; 

	for (i = 0; i < 20; i++) 
	{ 
		mul10(temp_A_key,(unsigned int)(A_KEY_DIGITS[i] - '0')); 
	} 

	A_key_checksum = Calc_Checksum(temp_A_key); 

	/* convert checksum to decimal digits */ 

	for (i = 0; i < 6; i++) 
	{ 
		A_KEY_CHECKSUM[5-i] = '0' + (char)(A_key_checksum % 10); 
		A_key_checksum /= 10; 
	} 
}

BOOL c_cave::A_Key_Verify(const char A_KEY_DIGITS[26]) 
{ 
	int i; 
	unsigned char temp_A_key[8]; 
	unsigned long entered_checksum; 

	/* convert first 20 digits to 64-bit representation in temp_A_key */ 

	for (i = 0; i < 8; i++) 
		temp_A_key[i] = 0; 

	for (i = 0; i < 20; i++) 
	{ 
		mul10(temp_A_key,(unsigned int)(A_KEY_DIGITS[i] - '0')); 
	} 

	/* convert last 6 digits to entered checksum */ 

	entered_checksum = 0; 
	for (i = 20; i < 26; i++) 
	{ 
		entered_checksum = (entered_checksum * 10) + (A_KEY_DIGITS[i] - '0'); 
	} 

	if(Calc_Checksum(temp_A_key) == entered_checksum) 
	{ 
		for (i = 0; i < 8; i++) 
		{ 
			A_key[i] = temp_A_key[i]; 
			SSD_A[i] = SSD_B[i] = 0; 
		} 
		return TRUE; 
	} 
	else 
	{ 
		return FALSE; 
	} 
}


void c_cave::SSD_Generation(const unsigned char RANDSSD[7])
{ 
	int i,offset_1,offset_2; 

	for (i = 0; i < 4; i++) 
	{ 
		LFSR[i] = RANDSSD[i+3] ^ A_key[i] ^ A_key[i+4]; 
	} 

	if ((LFSR[0] | LFSR[1] | LFSR[2] | LFSR[3]) == 0) 
	{ 
		for (i = 0; i < 4; i++) 
			LFSR[i] = RANDSSD[i+3]; 
	} 

	for (i = 0; i < 8; i++) 
		Register[i] = A_key[i]; 

	Register[8] = AAV; 

	for (i = 9; i < 12; i++) 
		Register[i] = RANDSSD[i-9]; 

	for (i = 12; i < 16; i++) 
		Register[i] = ESN[i-12]; 

	offset_1 = offset_2 = 128; 
	CAVE(8, &offset_1, &offset_2); 

	for (i = 0; i < 8; i++) 
	{ 
		SSD_A_NEW[i] = Register[i]; 
		SSD_B_NEW[i] = Register[i+8]; 
	} 
}

void c_cave::SSD_Update(void)
{ 
	int i; 

	for (i = 0; i < 8; i++) 
	{ 
		SSD_A[i] = SSD_A_NEW[i]; 
		SSD_B[i] = SSD_B_NEW[i]; 
	} 
}  

unsigned long c_cave::Auth_Signature(const unsigned char RAND_CHALLENGE[4], /*randbs */ const unsigned char AUTH_DATA[3], //IMSi_m_S1
			const unsigned char *SSD_AUTH/*ssd-A*/, const int SAVE_REGISTERS/*目前写的是0*/) 
{ 
	int i,offset_1,offset_2; 
	unsigned long AUTH_SIGNATURE; 

	for (i = 0; i < 4; i++) 
	{ 
		LFSR[i] = RAND_CHALLENGE[i] ^ SSD_AUTH[i] ^ SSD_AUTH[i+4]; 
	} 

	if ((LFSR_A | LFSR_B | LFSR_C | LFSR_D) == 0) 
	{ 
		for (i = 0; i < 4; i++) 
			LFSR[i] = RAND_CHALLENGE[i]; 
	} 

	/* put SSD_AUTH into r0-r7 */ 

	for (i = 0; i < 8; i++) 
		Register[i] = SSD_AUTH[i]; 

	Register[8] = AAV; 

	/* put AUTH_DATA into r9-r11 */ 

	for (i = 9; i < 12; i++) 
		Register[i] = AUTH_DATA[i-9]; 

	/* put ESN into r12-r15 */ 

	for (i = 12; i < 16; i++) 
		Register[i] = ESN[i-12]; 

	offset_1 = offset_2 = 128; 
	CAVE(8, &offset_1, &offset_2); 

	AUTH_SIGNATURE = 
	( ((unsigned long)(Register[0] ^ Register[13]) << 16) + 
	((unsigned long)(Register[1] ^ Register[14]) << 8) + 
	((unsigned long)(Register[2] ^ Register[15]) )) & 0x3ffff;
	

	if (SAVE_REGISTERS)
	{ 
		/* save LFSR and offsets */ 

		SAVED_OFFSET_1 = offset_1; 
		SAVED_OFFSET_2 = offset_2; 
		for (i = 0; i < 4; i++) 
		{ 
			SAVED_LFSR[i] = LFSR[i]; 
			SAVED_RAND[i] = RAND_CHALLENGE[i]; 
			if (i < 3) 
			{ 
				SAVED_DATA[i] = AUTH_DATA[i]; 
			} 
		} 
	} 

	return(AUTH_SIGNATURE); 
}  

void c_cave::roll_LFSR(void)
{
	BYTE	i;

	LFSR_A = Register[0];
	LFSR_B = Register[1];
	LFSR_C = Register[14];
	LFSR_D = Register[15];

	if((LFSR_A | LFSR_B | LFSR_C | LFSR_D) == 0)
	{
		for(i = 0 ; i < 4 ; i++)
			LFSR[i] = SAVED_RAND[i];
	}
}

void c_cave::Key_VPM_Generation(void)
{
	BYTE	i,j,r_ptr,offset_1,offset_2,vpm_ptr;

	/*iteration 1 , first pass through CAVE */

	for(i = 0 ; i <4 ; i++)
		LFSR[i] = SAVED_LFSR[i]^SSD_B[i]^SSD_B[i+4];

	if((LFSR_A | LFSR_B | LFSR_C | LFSR_D) == 0)
	{
		for(i = 0 ; i < 4 ; i++)
			LFSR[i] = SAVED_RAND[i];
	}

	for(i = 0 ; i < 8 ; i++)
		Register[i] = SSD_B[i];
	
	Register[8] = AAV;

	/* put SAVED_DATA into r9-r11 */

	for(i = 9 ; i < 12 ; i++)
		Register[i] = SAVED_DATA[i - 9];

	/*put ESN into r12-r15*/
	for(i = 12 ; i < 16 ; i++)
		Register[i] = ESN[i-12];

	offset_1 = SAVED_OFFSET_1;
	offset_2 = SAVED_OFFSET_2;

	CAVE(8 , (int *)&offset_1 , (int *)&offset_2);

	/* iteration 2 , generation of first CMEA key parameters */
	roll_LFSR();
	CAVE(4 , (int *)&offset_1 , (int *)&offset_2);

	for(i = 0 ; i < 4 ; i++)
		cmeakey[i] = Register[i + 4] ^ Register[i + 8];

	/*iteration 3 , genaration of second CMEA key parameters */

	roll_LFSR();
	CAVE(4 , (int *)&offset_1 , (int *)&offset_2);
	for(i = 4 ; i < 8 ; i++)
		cmeakey[i] = Register[i] ^ Register[i + 4];

	/*iteration 4-13 , generation of VPM */

	vpm_ptr = 0;
	for(i = 0 ; i < 10 ; i++)
	{
		roll_LFSR();
		CAVE(4 , (int *)&offset_1 , (int *)&offset_2);
		for(r_ptr = 0 ; r_ptr < 6 ; r_ptr++)
		{
			VPM[vpm_ptr] = Register[r_ptr+2] ^ Register[r_ptr+8];
			vpm_ptr++;
		}
	}
	
	/*iteration 14, generation of last VPM bits */

	roll_LFSR();
	CAVE(4 , (int *)&offset_1 , (int *)&offset_2);
	for(j = 0 ; j < 5 ; j++)
	{
		VPM[vpm_ptr] = Register[j+2] ^ Register[j+8];
		vpm_ptr++;
	}
}